package database

import (
	"bufio"
	"database/sql"
	"encoding/hex"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"hust_backend/main/api"

	"github.com/gin-gonic/gin"
)

const defaultExportLimit = 20

var createdCandidates = []string{
	"created_at", "created_time", "created", "date_created", "time_create",
	"createdOn", "createdAt", "created_date", "created_datetime",
}

type columnInfo struct {
	Name  string
	Type  string
	Key   string
	Extra string
}

func ExportDataHandler(c *gin.Context) {
	if c.Request.Method == http.MethodOptions {
		c.Status(http.StatusOK)
		return
	}

	limit := parseLimit(c.Query("limit"))
	cfg := LoadConfig()
	if cfg.Database == "" {
		api.Print_json(c, "status", "0", "message", "missing database name")
		return
	}

	conn, err := Open()
	if err != nil {
		api.Print_json(c, "status", "0", "message", err.Error())
		return
	}

	baseDir, err := os.Getwd()
	if err != nil {
		baseDir = "."
	}
	outDir := filepath.Join(baseDir, "main", "database")
	if err := os.MkdirAll(outDir, 0755); err != nil {
		api.Print_json(c, "status", "0", "message", err.Error())
		return
	}
	outFile := filepath.Join(outDir, "database_newest.sql")

	tables, err := fetchTables(conn, cfg.Database)
	if err != nil {
		api.Print_json(c, "status", "0", "message", err.Error())
		return
	}

	if err := exportTables(conn, cfg.Database, tables, outFile, limit); err != nil {
		api.Print_json(c, "status", "0", "message", err.Error())
		return
	}

	api.Print_json(
		c,
		"status", "1",
		"message", "exported",
		"file", outFile,
		"tables", len(tables),
		"limit", limit,
	)
}

func parseLimit(raw string) int {
	raw = strings.TrimSpace(raw)
	if raw == "" {
		return defaultExportLimit
	}
	value, err := strconv.Atoi(raw)
	if err != nil || value <= 0 {
		return defaultExportLimit
	}
	if value > 1000 {
		return 1000
	}
	return value
}

func exportTables(conn *sql.DB, dbName string, tables []string, outFile string, limit int) error {
	file, err := os.Create(outFile)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := bufio.NewWriter(file)
	defer writer.Flush()

	writeLine := func(text string) {
		if text == "" {
			_, _ = writer.WriteString("\n")
			return
		}
		_, _ = writer.WriteString(text + "\n")
	}

	writeLine("-- Export generated by export_data.go")
	writeLine("-- Database: " + dbName)
	writeLine("-- Time: " + time.Now().Format(time.RFC3339))
	writeLine("")
	writeLine("SET NAMES utf8mb4;")
	writeLine("SET FOREIGN_KEY_CHECKS=0;")
	writeLine("")
	writeLine("CREATE DATABASE IF NOT EXISTS " + qid(dbName) + " DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;")
	writeLine("USE " + qid(dbName) + ";")
	writeLine("")

	for _, table := range tables {
		writeLine("-- ====================================================")
		writeLine("-- TABLE: " + table)
		writeLine("-- ====================================================")
		writeLine("")

		createSQL, err := fetchCreateTable(conn, table)
		if err != nil || createSQL == "" {
			writeLine("-- Skipped (cannot read schema): " + table)
			writeLine("")
			continue
		}

		writeLine("DROP TABLE IF EXISTS " + qid(table) + ";")
		writeLine(createSQL + ";")
		writeLine("")

		cols, err := fetchColumns(conn, table)
		if err != nil || len(cols) == 0 {
			writeLine("-- No columns?")
			writeLine("")
			continue
		}

		colNames := make([]string, 0, len(cols))
		colTypeMap := make(map[string]string, len(cols))
		colKeyMap := make(map[string]string, len(cols))
		colExtraMap := make(map[string]string, len(cols))
		for _, col := range cols {
			colNames = append(colNames, col.Name)
			colTypeMap[col.Name] = col.Type
			colKeyMap[col.Name] = col.Key
			colExtraMap[col.Name] = col.Extra
		}

		orderCol := pickOrderColumn(colNames, colTypeMap, colKeyMap, colExtraMap)
		query := fmt.Sprintf("SELECT * FROM %s ORDER BY %s DESC LIMIT %d", qid(table), qid(orderCol), limit)
		rows, err := conn.Query(query)
		if err != nil {
			writeLine("-- Skipped (query failed): " + table)
			writeLine("")
			continue
		}

		columnOrder, _ := rows.Columns()
		indexMap := make(map[string]int, len(columnOrder))
		for i, name := range columnOrder {
			indexMap[name] = i
		}

		count := 0
		for rows.Next() {
			values := make([]any, len(columnOrder))
			pointers := make([]any, len(columnOrder))
			for i := range values {
				pointers[i] = &values[i]
			}
			if err := rows.Scan(pointers...); err != nil {
				continue
			}

			colSQL := make([]string, 0, len(colNames))
			valSQL := make([]string, 0, len(colNames))
			for _, colName := range colNames {
				colSQL = append(colSQL, qid(colName))
				idx, ok := indexMap[colName]
				if !ok {
					valSQL = append(valSQL, "NULL")
					continue
				}
				valSQL = append(valSQL, sqlValue(values[idx], colTypeMap[colName]))
			}

			insert := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s);", qid(table), strings.Join(colSQL, ","), strings.Join(valSQL, ","))
			writeLine(insert)
			count++
		}
		rows.Close()

		if count == 0 {
			writeLine("-- (no rows exported)")
		}
		writeLine("")
	}

	writeLine("SET FOREIGN_KEY_CHECKS=1;")
	return nil
}

func fetchTables(conn *sql.DB, dbName string) ([]string, error) {
	rows, err := conn.Query(
		`SELECT TABLE_NAME
		 FROM INFORMATION_SCHEMA.TABLES
		 WHERE TABLE_SCHEMA = ? AND TABLE_TYPE = 'BASE TABLE'
		 ORDER BY TABLE_NAME`,
		dbName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tables []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		tables = append(tables, name)
	}
	return tables, nil
}

func fetchCreateTable(conn *sql.DB, table string) (string, error) {
	row := conn.QueryRow("SHOW CREATE TABLE " + qid(table))
	var name, createSQL string
	if err := row.Scan(&name, &createSQL); err != nil {
		return "", err
	}
	return createSQL, nil
}

func fetchColumns(conn *sql.DB, table string) ([]columnInfo, error) {
	rows, err := conn.Query("SHOW COLUMNS FROM " + qid(table))
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	cols := []columnInfo{}
	for rows.Next() {
		var field, colType, nullVal, key, defaultVal, extra sql.NullString
		if err := rows.Scan(&field, &colType, &nullVal, &key, &defaultVal, &extra); err != nil {
			return nil, err
		}
		cols = append(cols, columnInfo{
			Name:  field.String,
			Type:  colType.String,
			Key:   key.String,
			Extra: extra.String,
		})
	}
	return cols, nil
}

func pickOrderColumn(colNames []string, colTypeMap, colKeyMap, colExtraMap map[string]string) string {
	for _, cand := range createdCandidates {
		if colType, ok := colTypeMap[cand]; ok && isTimeLikeType(colType) {
			return cand
		}
	}
	for _, name := range colNames {
		if strings.Contains(strings.ToLower(colExtraMap[name]), "auto_increment") {
			return name
		}
	}
	for _, name := range colNames {
		if strings.ToUpper(colKeyMap[name]) != "PRI" {
			continue
		}
		if isNumericType(colTypeMap[name]) {
			return name
		}
	}
	for _, name := range colNames {
		if strings.ToUpper(colKeyMap[name]) == "PRI" {
			return name
		}
	}
	for _, cand := range []string{"id", "ID"} {
		if colType, ok := colTypeMap[cand]; ok && isNumericType(colType) {
			return cand
		}
	}
	if len(colNames) == 0 {
		return "id"
	}
	return colNames[0]
}

func isTimeLikeType(colType string) bool {
	t := strings.ToLower(colType)
	return strings.Contains(t, "datetime") ||
		strings.Contains(t, "timestamp") ||
		strings.Contains(t, "date") ||
		strings.Contains(t, "time") ||
		strings.Contains(t, "int")
}

func isNumericType(colType string) bool {
	t := strings.ToLower(colType)
	return strings.Contains(t, "int") ||
		strings.Contains(t, "decimal") ||
		strings.Contains(t, "float") ||
		strings.Contains(t, "double")
}

func sqlValue(value any, mysqlType string) string {
	if value == nil {
		return "NULL"
	}
	if strings.Contains(strings.ToLower(mysqlType), "blob") ||
		strings.Contains(strings.ToLower(mysqlType), "binary") {
		switch v := value.(type) {
		case []byte:
			return "0x" + hex.EncodeToString(v)
		case string:
			return "0x" + hex.EncodeToString([]byte(v))
		default:
			return "0x" + hex.EncodeToString([]byte(fmt.Sprint(v)))
		}
	}
	if isNumericType(mysqlType) {
		switch v := value.(type) {
		case bool:
			if v {
				return "1"
			}
			return "0"
		case int, int8, int16, int32, int64,
			uint, uint8, uint16, uint32, uint64,
			float32, float64:
			return fmt.Sprint(v)
		case []byte:
			if looksNumeric(string(v)) {
				return string(v)
			}
		case string:
			if looksNumeric(v) {
				return v
			}
		}
	}

	switch v := value.(type) {
	case time.Time:
		return quoteSQL(v.Format("2006-01-02 15:04:05"))
	case []byte:
		return quoteSQL(string(v))
	case string:
		return quoteSQL(v)
	default:
		return quoteSQL(fmt.Sprint(v))
	}
}

func quoteSQL(value string) string {
	s := strings.ReplaceAll(value, "\\", "\\\\")
	s = strings.ReplaceAll(s, "'", "\\'")
	s = strings.ReplaceAll(s, "\r", "\\r")
	s = strings.ReplaceAll(s, "\n", "\\n")
	s = strings.ReplaceAll(s, "\t", "\\t")
	s = strings.ReplaceAll(s, "\x00", "\\0")
	s = strings.ReplaceAll(s, "\x1a", "\\Z")
	return "'" + s + "'"
}

func looksNumeric(value string) bool {
	value = strings.TrimSpace(value)
	if value == "" {
		return false
	}
	if _, err := strconv.ParseInt(value, 10, 64); err == nil {
		return true
	}
	_, err := strconv.ParseFloat(value, 64)
	return err == nil
}

func qid(name string) string {
	return "`" + strings.ReplaceAll(name, "`", "``") + "`"
}
